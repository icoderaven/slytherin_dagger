/** @file guided_mode_gtk.c
 *	@brief Function definitions to implement the guided mode part of the gui.
 *	Note that this file works along with all of the gtk_* files to set up
 *	the interface and handle callbacks. This is necessary in order to make
 *	file generated by glade plug in without too much modification.
 *
 *	@author Cornell Wright
 */
#include "config_defaults.h"
#include "motor_abs.h"
#include "guided_motions.h"
#include "log.h"
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <windows.h>
#include <math.h>
#include "CardioError.h"
#include "ErrorData.h"
#include "superCommon.h"

#include "gui_support.h"
#include <GL/glut.h>
#include "../snakeVisualizer/snakelibgl.h"
#include "../snakeVisualizer/polygonMesh.h"
#include "../snakeVisualizer/autonomy.h"

extern autonomy *myAutonomy;

/** Buttons for CTi Joystick - (03.03.09 -Brad B) */
#define PAUSE_BTN 2
#define STEPPED_BTN 1
#define RETRACT_BTN 0
#define WITHDRAW_INNER_BTN 4
#define REINSERT_INNER_BTN 5
#define CONTINUOUS_BTN 6
#define EXECUTE_BTN 3
#define TEST_BTN 4
#define STEER_X_AXIS 0
#define STEER_Y_AXIS 1
#define STEER_Z_AXIS 3


/** @brief The highest numbered button above + 1 */
#define NUM_BUTTONS 8

/** @brief Max value read from a joystick axis */
#define JOY_MAX 0xffff

/** @brief Centers a 0-JOY_MAX joystick read to -JOY_MAX to +JOY_MAX */
#define JOY_CENTER(val) (((int)(val) - (JOY_MAX >> 1)) << 1)

/** @brief Normalizes a joystick reading with the deadzone specified in the
 *	config file.
 */
#define JOY_NORMALIZE(val)												\
	((fabs((float)(val)) < JOY_DEADZONE * JOY_MAX) ?		\
		(0.0f)															\
	:																	\
		(((float)(val) - (((val) < 0) ? -1 : 1) *						\
				(JOY_DEADZONE * JOY_MAX)) /				\
				(JOY_MAX - JOY_DEADZONE * JOY_MAX)))


/** @brief How many buttons there are on the joystick */
static int joy_num_buttons = 0;

/** @brief Maintains our current separation distance. Note that this isn't
 *	currently supported.
 */
static float sep;

/** @brief Set to true if this is the first time through the loop that
 *	this button is pressed for. This prevents holding a button down from
 *	being seen as multiple button presses */
static int btn_click[NUM_BUTTONS];
/** @brief Shows if the button is down the last time through the loop */
static int btn_down[NUM_BUTTONS];



/** @brief Initializes guided mode interface */
void guided_mode_init(void) {
	int i;
	JOYINFO joy_values;
	JOYCAPS joy_capabilities;

	// Initialized the button arrays
	for (i = 0; i < NUM_BUTTONS; i++) {
		btn_click[i] = 0;
		btn_down[i] = 0;
	}

	// Set the separation to the default value
	sep = guided_separation;

	// Print a warning if we don't detect a joystick on init.
	if (joyGetPos(JOYSTICKID1, &joy_values) != JOYERR_NOERROR) {
		printf("No joystick detected. Joystick will not be supported.\n");
	}
	else {
		// If we opened the joystick sucessfully, get the number of buttons
		if (joyGetDevCaps(JOYSTICKID1, &joy_capabilities,
				sizeof(joy_capabilities)) == JOYERR_NOERROR) {
			joy_num_buttons = joy_capabilities.wMaxButtons;
		}
	}
}


/** @brief Main loop for the guided mode interface. */
void guided_mode_main(void) {
	
	// Used to print out the current mode
	char my_mode[50];
	// X and why positions of the joystick normalized to range [-1.0, 1.0]
	float joyx, joyy;
	int i;
	JOYINFO joy_values;


	// Check to see if there are any warnings, and turn on the warning image
	// if there are
	if (log_warning_this_run) {
		update_image_sensitive("image6", TRUE);
	}

	// Check to see if there are any errors, and turn on the error image
	// if there are
	if (log_error_this_run) {
		update_image_sensitive("image7", TRUE);
	}



	// Handle joystick stuff if we have one to command the probe
	// Requirement 12.1
	if (joyGetPos(JOYSTICKID1, &joy_values) == JOYERR_NOERROR) {
		// Update all joysticks
		PresentJoyStickPacketNumber++;    //at least we tired to update

		// If we're in a steering mode, look at the x and y axes
		if (guided_mode == STEPPED_STEERING || guided_mode == RETRACT_STEERING){

			// Normalize the axes so that they are in the range [-1, 1],
			// taking the deadzone into account
			joyx = JOY_NORMALIZE(JOY_CENTER(joy_values.wXpos));
			joyy = JOY_NORMALIZE(JOY_CENTER(joy_values.wYpos));
			joyy = -joyy;

			// or get the inputs from the autonomous driving class
			if (myAutonomy && myAutonomy->getAutonomousDrivingFlag()) {
				joyx = myAutonomy->getAutonomousJoystickX();
				joyy = myAutonomy->getAutonomousJoystickY();
			}
			CurrentJoyX = joyx;
			CurrentJoyY = joyy;


			// Send this as our steering input
			steer(joyx, joyy);

			// Update the steering sliders
			update_slider_pos("hscale20", joyx);
			update_slider_pos("vscale1", joyy);
		}

		// Process all the buttons
		for (i = 0; i < NUM_BUTTONS && i < joy_num_buttons; i++) {

			// See if the given button was pressed
			if (joy_values.wButtons & (1 << i)) {
				// If this is the first time we've seen it go from depressed
				// to pressed mark it as pressed and show a click
				if (! btn_down[i]) {
					btn_click[i] = 1;
					btn_down[i] = 1;
				}
				// If it was pressed the last time through the loop, do not
				// show a click
				else {
					btn_click[i] = 0;
				}
			}
			// If the button is not down, then show that it is depressed and
			// not clicked.
			else {
				btn_down[i] = 0;
				btn_click[i] = 0;
			}
		}
		/******************************************************************
        jwm - code added to get out of safe state. Need to press pause button
		        and stepped button at the same time. The system will return to
		        pause state.                                               
          ****************************************************************/
        if ((ErrorState == SAFE_STATE) && (btn_down[PAUSE_BTN])
            && (btn_click[STEPPED_BTN])){
            RecoverFlag = TRUE;
            //clear the buttons
            btn_click[PAUSE_BTN] = 0;
            btn_click[STEPPED_BTN] = 0;
        }

		// If the pause button is pressed, toggle the paused state
		if (btn_click[PAUSE_BTN]) {
			if (! guided_paused) {
				// Requirement 12.3.1
				pause();
			}
			else if(ErrorState == RUN_STATE){
				// Requirement 12.3.2
				unpause();
			}
		}

		// All the set_mode commands below satisfy requirement 12.3.5

		// If the stepped mode button is pressed, set us to stepped mode
		if (btn_click[STEPPED_BTN]) {
			set_mode(STEPPED);
		}

		// If the retract mode button is pressed, set us to retract mode
		if (btn_click[RETRACT_BTN]) {
			set_mode(RETRACT);
		}

		// If the stepped button is held down while pressing retract button,
		// set us to homing mode
		if (btn_down[STEPPED_BTN] && btn_click[RETRACT_BTN]) {
			set_mode(HOMING);
		}

		// If the execute button is pressed, send an execute command to guided
		// motions
		// Requirement 12.3.5
		if (btn_click[EXECUTE_BTN] && (guided_mode == STEPPED_STEERING ||
				guided_mode == RETRACT_STEERING)) {
			execute();
		}

	}

	// Provide feedback to the user.
	// Requirement 12.2


	// Update the position sliders
	update_slider_pos("inner_slide_actual_pos_guided",
			get_position(INNER_SLIDE));
	update_slider_pos("outer_slide_actual_pos_guided",
			get_position(OUTER_SLIDE));
	update_slider_pos("inner_actual_pos_guided",
			get_position(INNER_TENSIONER));
	update_slider_pos("bot_actual_pos_guided",
			get_position(BOT_TENSIONER));
	update_slider_pos("ul_actual_pos_guided",
			get_position(UL_TENSIONER));
	update_slider_pos("ur_actual_pos_guided",
			get_position(UR_TENSIONER));


	// Update the force sliders
	update_slider_pos("inner_slide_actual_force_guided",
			get_force(INNER_SLIDE));
	update_slider_pos("outer_slide_actual_force_guided",
			get_force(OUTER_SLIDE));
	update_slider_pos("inner_actual_force_guided",
			get_force(INNER_TENSIONER));
	update_slider_pos("bot_actual_force_guided",
			get_force(BOT_TENSIONER));
	update_slider_pos("ul_actual_force_guided",
			get_force(UL_TENSIONER));
	update_slider_pos("ur_actual_force_guided",
			get_force(UR_TENSIONER));


	// Update the current mode display
	switch (guided_mode) {
		case HOMING_SCREWS: strcpy_s(my_mode, sizeof(my_mode), "Homing Screws"); break;
		case STEPPED_STEERING: strcpy_s(my_mode, sizeof(my_mode), "Stepped Steering"); break;
		case STEPPED_ADVANCE_INNER: strcpy_s(my_mode, sizeof(my_mode), "Stepped Advance Inner"); break;
		case STEPPED_ADVANCE_OUTER: strcpy_s(my_mode, sizeof(my_mode), "Stepped Advance Outer"); break;
		case RETRACT_INNER: strcpy_s(my_mode, sizeof(my_mode), "Retract Inner"); break;
		case RETRACT_OUTER: strcpy_s(my_mode, sizeof(my_mode), "Retract Outer"); break;
		case RETRACT_STEERING: strcpy_s(my_mode, sizeof(my_mode), "Retract Steering"); break;
		case INITIALIZING_INIT: strcpy_s(my_mode, sizeof(my_mode), "Initializing"); break;
		case ABANDON_ABANDONING: strcpy_s(my_mode, sizeof(my_mode), "Abandoning Last Motion"); break;
		default: strcpy_s(my_mode, sizeof(my_mode), "UNKNOWN!"); break;
	}

	update_label_text("label68", my_mode);

	// Update the next mode display
	switch (change_mode) {
		case -1: strcpy_s(my_mode, "none"); break;
		case HOMING_SCREWS: strcpy_s(my_mode, sizeof(my_mode), "Homing Screws"); break;
		case STEPPED_STEERING: strcpy_s(my_mode, sizeof(my_mode), "Stepped Steering"); break;
		case STEPPED_ADVANCE_INNER: strcpy_s(my_mode, sizeof(my_mode), "Stepped Advance Inner"); break;
		case STEPPED_ADVANCE_OUTER: strcpy_s(my_mode, sizeof(my_mode), "Stepped Advance Outer"); break;
		case RETRACT_INNER: strcpy_s(my_mode, sizeof(my_mode), "Retract Inner"); break;
		case RETRACT_OUTER: strcpy_s(my_mode, sizeof(my_mode), "Retract Outer"); break;
		case RETRACT_STEERING: strcpy_s(my_mode, sizeof(my_mode), "Retract Steering"); break;
		case INITIALIZING_INIT: strcpy_s(my_mode, sizeof(my_mode), "Initializing"); break;
		case ABANDON_ABANDONING: strcpy_s(my_mode, sizeof(my_mode), "Abandon Last Motion"); break;
		default: strcpy_s(my_mode, sizeof(my_mode), "UNKNOWN!"); break;
	}

	update_label_text("next_mode", my_mode);
	

	// Show if we're paused or not
	if (guided_paused) {
        if(ErrorState != RUN_STATE){
           if (ErrorState == SAFE_STATE_NO_RECOVER) {
		   	   update_label_text("pause_label", "Unrecoverable Error");
		   }
		   else {
			   update_label_text("pause_label","Error Paused");
		   }
        }
        else{
		   update_label_text("pause_label", "Paused");
        }
	}
	else {
		update_label_text("pause_label", "Running");
	}

}


/** @brief Handles printing a new line from the log to the UI
 *	@param log_line Pointer to line just added to the log file.
 */
void new_log_line(char *log_line)
{

	append_textview("textview1", log_line, strlen(log_line));

}
